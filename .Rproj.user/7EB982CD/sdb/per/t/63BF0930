{
    "collab_server" : "",
    "contents" : "#include \"distanceAPI.h\"\n\nvoid distanceAPI::init(arma::mat& x, std::string method, std::size_t p) {\n  this->set_distance(method, p);\n  this->calc(x);\n};\n\nvoid distanceAPI::set_distance(std::string distMethod, std::size_t p) {\n  if (distMethod.compare(\"euclidian\") == 0) {\n    euclidianDistance dist;\n    dist.set_parameters();\n    dist_ = std::make_shared<euclidianDistance>(dist);\n  } else if (distMethod.compare(\"manhattan\") == 0) {\n    manhattanDistance dist;\n    dist.set_parameters();\n    dist_ = std::make_shared<manhattanDistance>(dist);\n  } else if (distMethod.compare(\"minkowski\") == 0) {\n    minkowskiDistance dist;\n    dist.set_parameters(p);\n    dist_ = std::make_shared<minkowskiDistance>(dist);\n  } else if (distMethod.compare(\"maximum\") == 0) {\n    maximumDistance dist;\n    dist.set_parameters();\n    dist_ = std::make_shared<maximumDistance>(dist);\n  } else if (distMethod.compare(\"cosine\") == 0) {\n    cosineDistance dist;\n    dist.set_parameters();\n    dist_ = std::make_shared<cosineDistance>(dist);\n  } else {\n    distance dist;\n    dist_ = std::make_shared<distance>(dist);\n  }\n};\n\nvoid distanceAPI::calc(arma::mat& x) {\n  int nrow = x.n_rows;\n  output_ = arma::vec(nrow * (nrow - 1) / 2);\n  parallelDistance parallelDistance(x, dist_, nrow, output_);\n  parallelFor(0, nrow, parallelDistance);\n};\n\n\n/**\n * Weighted Distance Calculation\n */\nvoid weightedDistanceAPI::init(arma::mat& x, arma::rowvec& weights) {\n  this->set_distance(weights);\n  this->calc(x);\n}\n\nvoid weightedDistanceAPI::set_distance(arma::rowvec& weights) {\n  weightedDistance dist;\n  dist.set_parameters(weights);\n  dist_ = std::make_shared<weightedDistance>(dist);\n};\n\n\n/**\n * XY Distance Calculation\n */\nvoid xyDistanceAPI::init(arma::mat& x, arma::mat& y, std::string method, std::size_t p) {\n  this->set_distance(method, p);\n  this->calc(x, y);\n};\n\nvoid xyDistanceAPI::calc(arma::mat& x, arma::mat& y) {\n  int nrow = x.n_rows;\n  arma::mat output(nrow, y.n_rows);\n  output_ = output;\n  parallelDistanceNM parallelDistanceNM(x, y, dist_, nrow, output_);\n  parallelFor(0, nrow, parallelDistanceNM);\n};\n\n\n/**\n * Weighted XY Distance Calculation\n */\nvoid weightedXYDistanceAPI::init(arma::mat& x, arma::mat& y, arma::rowvec& weights) {\n  this->set_distance(weights);\n  this->calc(x, y);\n}\n\nvoid weightedXYDistanceAPI::set_distance(arma::rowvec& weights) {\n  weightedDistance dist;\n  dist.set_parameters(weights);\n  dist_ = std::make_shared<weightedDistance>(dist);\n};\n\nvoid weightedXYDistanceAPI::calc(arma::mat& x, arma::mat& y) {\n  int nrow = x.n_rows;\n  arma::mat output(nrow, y.n_rows);\n  output_= output;\n  parallelDistanceNM parallelDistanceNM(x, y, dist_, nrow, output_);\n  parallelFor(0, nrow, parallelDistanceNM);\n};\n\n/**\n * RandomForests Terminal Node Distance\n */\nvoid rfTerminalNodeDistanceAPI::init(arma::umat& nodeIDs) {\n  rangerForest rf(nodeIDs);\n  output_ = rf.nodeDistance();\n}\n\n\n/**\n * RandomForests Proximity Matrix\n */\nvoid rfProximityDistanceAPI::init(arma::mat& x) {\n  this->set_distance(x);\n  this->calc(x);\n}\n\nvoid rfProximityDistanceAPI::set_distance(arma::mat& x) {\n  rangerProximity dist;\n  dist.set_parameters(x.n_cols);\n  dist_ = std::make_shared<rangerProximity>(dist);\n}\n\n\n/**\n * RandomForests XY Proximity Matrix\n */\nvoid rfProximityXYDistanceAPI::init(arma::mat& x, arma::mat& y) {\n  this->set_distance(x);\n  this->calc(x, y);\n};\n\nvoid rfProximityXYDistanceAPI::calc(arma::mat& x, arma::mat& y) {\n  int nrow = x.n_rows;\n  arma::mat output(nrow, y.n_rows);\n  output_ = output;\n  parallelDistanceNM parallelDistanceNM(x, y, dist_, nrow, output_);\n  parallelFor(0, nrow, parallelDistanceNM);\n};\n\n\n/**\n * RandomForests Depth Distance\n */\nvoid rfDepthDistanceAPI::init(arma::mat& xNodeIDs, arma::umat& terminalNodeIDs) {\n  // calculate terminal node edge length\n  rangerForest rf(terminalNodeIDs);\n  RfDistContainer nodeDists = rf.nodeDistance();\n  this->set_distance(nodeDists);\n  this->calc(xNodeIDs);\n}\n\nvoid rfDepthDistanceAPI::set_distance(RfDistContainer& nodeDists) {\n  rfDepthDistance dist;\n  dist.set_parameters(nodeDists);\n  dist_ = std::make_shared<rfDepthDistance>(dist);\n}\n\nvoid rfDepthDistanceAPI::calc(arma::mat& xNodeIDs) {\n  int nrow = xNodeIDs.n_rows;\n  arma::vec output(nrow * (nrow - 1) / 2);\n  output_ = output;\n  parallelDistance parallelDistance(xNodeIDs, dist_, nrow, output_);\n  parallelFor(0, nrow, parallelDistance);\n};\n\n\n/**\n * RandomForests XY Depth Distance\n */\nvoid rfDepthXYDistanceAPI::init(arma::mat& xNodeIDs, arma::mat& yNodeIDs, arma::umat& terminalNodeIDs) {\n  // calculate terminal node edge length\n  rangerForest rf(terminalNodeIDs);\n  RfDistContainer nodeDists = rf.nodeDistance();\n  this->set_distance(nodeDists);\n  this->calc(xNodeIDs, yNodeIDs);\n}\n\nvoid rfDepthXYDistanceAPI::calc(arma::mat& xNodeIDs, arma::mat& yNodeIDs) {\n  int nrow = xNodeIDs.n_rows;\n  arma::mat output(nrow, yNodeIDs.n_rows);\n  output_ = output;\n  parallelDistanceNM parallelDistanceNM(xNodeIDs, yNodeIDs, dist_, nrow, output_);\n  parallelFor(0, nrow, parallelDistanceNM);\n};\n",
    "created" : 1490819572458.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1063473633",
    "id" : "63BF0930",
    "lastKnownWriteTime" : 1489097563,
    "last_content_update" : 1489097563,
    "path" : "D:/Programmierung/Github/similarity/src/distanceAPI.cpp",
    "project_path" : "src/distanceAPI.cpp",
    "properties" : {
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "cpp"
}